# 栈stack
## 栈结构与特性
* 栈（stack），它是一种受限的线性结构，其限制是仅允许在 表的一端 进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底
* 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素
* 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素
* 后进先出
* ![image](https://user-images.githubusercontent.com/82013367/217719618-9c0c24e3-e121-438a-b362-e5ca3c9da6ae.png)
## 简单面试题
![image](https://user-images.githubusercontent.com/82013367/217719704-6b48a9d6-c96c-4c42-9795-2ea1ac781bad.png)
答案：c
提示：后进先出
## 栈结构的实现
我们可以使用数组，链表实现栈，由于js没有实现链表，我们先使用数组
```
class ArrayStack {
   private data: any[] = []
   // 添加元素
   push(element: any): void {
    this.data.push(element)
   }
   // 删除元素
   pop(): any {
    return this.data.pop()
   }
   // 返回栈顶元素，不对栈做任何修改
   peek(): any {
    return this.data[this.data.length -1]
   }
   // 判断栈是否为空
   isEmpty(): boolean {
     return this.data.length === 0
   }
   // 返回栈里元素个数
   size(): number {
     return this.data.length
   }
}
const stack1 = new ArrayStack()

stack1.push('aaa')
stack1.push('bbb')
console.log(stack1);
console.log(stack1.pop());
console.log(stack1.peek());
console.log(stack1.isEmpty());
console.log(stack1.size());
```
上面我们使用的类型都是any，这不好，我们重构下
```
// 定义一个接口
interface IStack<T> {
  push(element: T): void
  pop(): T | undefined
  peek(): T | undefined
  isEmpty(): boolean
  size(): number
}
// ArrayStack实现IStack接口
class ArrayStack<T> implements IStack<T> {
  private data: T[] = []
  // 添加元素
  push(element: T): void {
    this.data.push(element)
  }
  // 删除元素
  pop(): T | undefined {
    return this.data.pop()
  }
  // 返回栈顶元素，不对栈做任何修改
  peek(): T | undefined {
    return this.data[this.data.length - 1]
  }
  // 判断栈是否为空
  isEmpty(): boolean {
    return this.data.length === 0
  }
  // 返回栈里元素个数
  size(): number {
    return this.data.length
  }
}
const stack1 = new ArrayStack<string>()
stack1.push('aaa')
const stack2 = new ArrayStack<number>()
stack2.push(123)

export { }
```
